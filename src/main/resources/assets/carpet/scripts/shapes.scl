//This is a library app, mostly for the draw command, which allows to import these shape-drawing functions into your own app.
//The _fill_flat functions are used in internal calls, and are not a part of the API
//These functions return a set of all the positions in the shape, given the parameters, without repeating a position.
//This way, you can efficiently iterate over the positions once having generated them. See draw_beta.sc for an example. todo change to draw once renamed
//You can also read the documentation code above each function to see what it does, how it does it and how well it does it
//One way you can speed things up is by threading the operations

//This algorithm draws a sphere by turning half a circle (in radians), then at each angle
//it turns another half circle in radians and then fills in the other half using - signs
//For a filled circle we just fill in the end points of the circle.
//If the radius argument is not an integer, it will draw some of the blocks from a sphere
//of radius floor(radius), and some from a sphere of radius ceil(radius).
//For safety, pass in floor(radius) as the argument to the function.
//Algorithmic efficiency:
//  O(n^2) for hollow spheres cos 2d surface
//  O(n^3) for filled spheres cos 3d volume
draw_sphere(centre, radius, hollow)->(
    positions = {};
    [cx,cy,cz]=centre;
    for(range(-90, 90, 45/radius),
        cpitch = cos(_);
        spitch = sin(_);
        for(range(0, 180, 45/radius),
            cyaw = cos(_)*cpitch*radius;
            syaw = sin(_)*cpitch*radius;
            if(hollow,
                positions += [cx+cyaw,cy+spitch*radius,cz+syaw];
                positions += [cx+cos(_+180)*cpitch*radius,cy+spitch*radius,cz+sin(_+180)*cpitch*radius],
                for(range(-syaw,syaw+1),
                    positions += [cx+cyaw*cpitch,cy+spitch*radius, cz+_]
                )
            )
        )
    );
    positions
);

//This function generates a hollow diamond, essentially by 3D printing it.
//It iterates along the radius, and at each point it draws a flat diamond in the y direction
//Algorithmic efficiency:
//  O(n^2) cos 2d surface
draw_diamond(pos, radius)->(
    positions = {};
    c_for(r=0, r<radius, r+=1,
        y = r-radius+1;
        c_for(x=-r,x<=r,x+=1,
            z=r-abs(x);
            positions += [pos:0+x, pos:1+y, pos:2+z];
            positions += [pos:0+x, pos:1+y, pos:2-z];
            positions += [pos:0+x, pos:1-y, pos:2+z];
            positions += [pos:0+x, pos:1-y, pos:2-z];
        )
    );
    positions
);

//Draws a filled diamond by drawing a bunch of hollow diamonds within
//While the code looks dodgy, it's equivalent to the filling algorithm
//which fills between the endpoints as opposed to just plotting them
//Algorithmic efficiency:
//  O(n^3) cos 3d volume
draw_filled_diamond(pos, radius)->(
    positions = {};
    loop(radius,
        positions = positions + draw_diamond(pos, _+1);
    );
    positions
);

//Draws a pyramid using a bunch of circles or squares of decreasing or increasing radii based on where it's pointing.
//Circles are drawn using _fill_flat_circle
//If radius is greater than height and shape is hollow, it will fill in the gaps between layers,
//drawing multiple shapes at the same y-level to maintain the slope
//Algorithmic efficiency:
//  O(n^2) for hollow cones / pyramids
//  O(n^3) for filled cones / pyramids
draw_pyramid(pos, radius, height, pointing, orientation, fill_type, is_square)->(
    positions = {};
    hollow = fill_type=='hollow';
    pointup = pointing=='up';
    for(range(height),
        h=_;
        r = if(pointup, (radius * ( 1 - h / height) - 1), radius * h / height);

        if(!hollow || (pointup&&h==0)||(!pointup && h==height-1),
            positions = positions + _fill_flat(pos, h, r, is_square, orientation, false, true),//Always close bottom off
            inner=if(radius<=height,
                r-1,
                2*radius+1>2*height,
                if(pointup, (radius * ( 1 - (h+1) / height) - 1), radius * (h+1) / height),
                r-2
            );
            for(range(inner, r),
                positions = positions + _fill_flat(pos, h, _+1, is_square, orientation, true, true)//Always close bottom off
            )
        );
    );
    positions
);

//Draws a prism as column of squares/circles (circles using _fill_flat_circle)
//Only thing special to note is that here we pre-generate the points
//and then use that with an offset to make the rest of the prism.
//This avoid re-running algorithms for generating the shapes, which tend to be costly
//Algorithmic efficiency:
//  O(n^2) for hollow cuboids / cylinders
//  O(n^3) for filled cuboids / cylinders
draw_prism(pos, rad, height, orientation, fill_type, is_square)->(
    positions = {};
    hollow = fill_type =='hollow';
    radius = rad+0.5;
    filled_circle_points = _fill_flat(pos, 0, radius, is_square, orientation, false, false); //I dont actually need to generate all the points lol
    offset_vector = if(orientation=='x', [1,0,0], orientation=='y', [0,1,0],[0,0,1]);
    if(hollow,
        hollow_circle_points = _fill_flat(pos, 0, radius, is_square, orientation, true, false);

        for(filled_circle_points,//Always close ends off
            positions+=_;
            positions+=_+offset_vector*(height-1)
        );

        for(range(1, height-1),//cos Im adding ends as filled anyways
            offset=_;
            for(hollow_circle_points,
                positions+= _ + offset_vector * offset
            )
        ),

        for(range(height),
            offset = _;
            for(filled_circle_points,
                positions += _ + offset_vector * offset
            )
        );
    );
    positions
);

//Allows to fill a rectangle or circle
//'pyramid' parameter is cos this function is called by draw_prism and draw_pyramid
//Now in pyramids, I want circles to be ever so slightly thicker,
//whereas in prisms I don't, hence the parameter.
//The reason I do abs() of the radius for _fill_flat_circle is because sometimes,
//the calculations result in -0 being inputted as a radius.
//Algorithmic efficiency:
//  O(n) for hollow circles / squares cos it's just a line
//  O(n^2) for filled circles / squares cos 2d surface
_fill_flat(pos, offset, dr, rectangle, orientation, hollow, pyramid)->
    if(rectangle,
        _fill_flat_rectangle(pos, offset, dr, orientation, hollow),
        _fill_flat_circle(pos, offset, abs(dr), orientation, hollow, pyramid)
    );


//Bresenham circle algorithm to be super efficient
//This is a modified verison from here: https://weber.itn.liu.se/~stegu76/circle/circlealgorithm.pdf
//That paper goes into a lot more detail on how to make it faster, but in scarpet it changes nothing
//Cos the optimizations are essentially to only use integer maths which is faster,
//but scarpet uses floating point maths anyways.
//But there is room for less calculation, by avoiding to recalculate (x+1)^2+(y-1/2)^2 every time
//Also, the original algorithm generates a thin circle,
//which means that cones and spheres have gaps between the layers.
//To solve, I plot an extra point if we're moving diagonally downwards, and that solves the issue entirely.
//But this caused other issues, so I added the 'thick' parameter to choose between the two options.
//Algorithmic efficiency:
//  O(n) for hollow circles cos it's just a line
//  O(n^2) for filled circles cos 2d surface
_fill_flat_circle(pos, offset, dr, orientation, hollow, thick) ->(

    r = floor(dr);

    positions = {};

    if(r == 0,
        offset_vector = if(orientation=='x', [1,0,0], orientation=='y', [0,1,0],[0,0,1]);
        positions += pos + offset_vector*offset;
        return(positions)
    );

    a=0;
    b=r;
    d = 1.25-r;

    while(a<=b, r, //technically the limit is r/sqrt(2) but whatevs
        positions = positions + _fill_flat_circle_points(pos, orientation, offset, hollow, a, b);
        if(d > 0,
	        d+=2*a-2*b+5;
	        b=b-1;
	        if(hollow && thick, //to make circles slightly thicker
	            positions = positions + _fill_flat_circle_points(pos, orientation, offset, hollow, a, b)
	        ),
	        d+=2*a+3
        );
        a+=1;
    );
    positions
);

//Method used to fill points in 8 octants.
//Used by Bresenham midpoint algorithm to use least code,
//exploiting the symmetricity of the circle.
//Algorithmic efficiency:
//  O(1) if hollow cos it's just 8 points
//  O(n) if filled cos it draws the lines between the points
_fill_flat_circle_points(pos, orientation, offset, hollow, a, b) ->(
    [x, y, z] = pos;
    positions = {};
    if(orientation == 'x',
        if(hollow,
            positions += [x + offset,y+a,z+b];
            positions += [x + offset,y+a,z-b];
            positions += [x + offset,y-a,z+b];
            positions += [x + offset,y-a,z-b];
            positions += [x + offset,y+b,z+a];
            positions += [x + offset,y+b,z-a];
            positions += [x + offset,y-b,z+a];
            positions += [x + offset,y-b,z-a],
            for(range(-b, b+1),
                positions += [x + offset,y+a,_ + z];
                positions += [x + offset,y-a,_ + z]
            );
            for(range(-a, a+1),
                positions += [x + offset,y+b,_ + z];
                positions += [x + offset,y-b,_ + z]
            )
        ),
        orientation=='y',
        if(hollow,
            positions += [x+a, y + offset,z+b];
            positions += [x+a, y + offset,z-b];
            positions += [x-a, y + offset,z+b];
            positions += [x-a, y + offset,z-b];
            positions += [x+b, y + offset,z+a];
            positions += [x+b, y + offset,z-a];
            positions += [x-b, y + offset,z+a];
            positions += [x-b, y + offset,z-a];
			,
            for(range(-b, b+1),
                positions += [x+a,y + offset,_ + z];
                positions += [x-a,y + offset,_ + z]
            );
            for(range(-a, a+1),
                positions += [x+b,y + offset,_ + z];
                positions += [x-b,y + offset,_ + z]
            )
        ),
        orientation=='z',
        if(hollow,
            positions += [x+a,y+b, z + offset];
            positions += [x+a,y-b, z + offset];
            positions += [x-a,y+b, z + offset];
            positions += [x-a,y-b, z + offset];
            positions += [x+b,y+a, z + offset];
            positions += [x+b,y-a, z + offset];
            positions += [x-b,y+a, z + offset];
            positions += [x-b,y-a, z + offset],
            for(range(-b, b+1),
                positions += [_ + x,y+a,z + offset];
                positions += [_ + x,y-a,z + offset]
            );
            for(range(-a, a+1),
                positions += [_ + x,y+b,z + offset];
                positions += [_ + x,y-b,z + offset]
            )
        )
    );
    positions
);

//Fills a square
//Algorithmic efficiency:
//  O(n) for hollow squares cos it's just a line
//  O(n^2) for filled squares cos 2d surface
_fill_flat_rectangle(pos, offset, dr, orientation, hollow) -> (
    r = floor(dr);
    [x, y, z] = pos;
    positions = {};
    if(orientation == 'x',
        c_for(a = -r, a <=r, a +=1,
            if(hollow,
                positions += [offset+x, a+y, r+z];
                positions += [offset+x, a+y,-r+z];
                positions += [offset+x, r+y, a+z];
                positions += [offset+x,-r+y, a+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [offset+x,a+y,b+z]
                )
            )
        ),
        orientation == 'y',
        c_for(a = -r, a <=r, a +=1,
            if(hollow,
                positions += [ r+x,offset+y,a+z];
                positions += [-r+x,offset+y,a+z];
                positions += [a+x,offset+y, r+z];
                positions += [a+x,offset+y,-r+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [a+x,offset+y,b+z]
                )
            )
        ),
        orientation == 'z',
        c_for(a = -r, a <=r, a +=1,
             if(hollow,
                positions += [ r+x,a+y,offset+z];
                positions += [-r+x,a+y,offset+z];
                positions += [a+x, r+y,offset+z];
                positions += [a+x,-r+y,offset+z],
                c_for(b = -r, b <=r, b +=1,
                    positions += [b+x,a+y,offset+z]
                )
            )
        ),
    );
    positions
);
